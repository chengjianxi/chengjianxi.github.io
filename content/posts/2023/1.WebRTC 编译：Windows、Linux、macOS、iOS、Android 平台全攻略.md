---
title: "WebRTC 编译：Windows、Linux、macOS、iOS、Android 平台全攻略"
date: 2023-02-19T17:55:28+08:00
description: ""
tags: []
type: post
weight: 1
showTableOfContents: true
---

## Windows 平台

### 构建需求

- `cmake` >= 3.5
- `Visual Studio 2022` 或者 `Visual Studio 2019` （libmediasoupclient 依赖的 *m94* 版本只能是 `Visual Studio 2019`）
- `Git`



### 下载源码

下载源码前首先配置代理服务器，打开命令行输入下面命令：

```shell
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890
set http_proxy=http://127.0.0.1:7890
set https_proxy=http://127.0.0.1:7890

git config --global http.sslVerify false
```

然后安装 `depot tools`，并加入环境变量：

```shell
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
```

另外，以同样的方式添加一个 `DEPOT_TOOLS_WIN_TOOLCHAIN` 环境变量，并将其设置为 `0`。这告诉 depot_tools 使用本地安装的 Visual Studio 版本（默认情况下，depot_tools 将尝试使用 google 内部版本）。

加入环境变量后，重新打开命令行，执行 `gclient`，它会自动下载所需要的第三方应用，例如：python 等。

前期准备完成后就可以获取 WebRTC 源代码了，在命令行中工具执行下面的代码：

```shell
# 设置VS编译的环境变量
set GYP_MSVS_VERSION=2022
set GYP_MSVS_OVERRIDE_PATH=C:\Program Files\Microsoft Visual Studio\2022\Community
set GYP_GENERATORS=msvs-ninja,ninja
# 设置使用本机VS进行编译
set DEPOT_TOOLS_WIN_TOOLCHAIN=0
cd %webrtc_src%
fetch --nohooks webrtc
gclient sync
cd src
# 切换到 libmediasoupclient 依赖的 m94 版本
# git checkout -b m94 refs/remotes/branch-heads/4606
# 或者切换到 m120 版本（分支对应的版本详见：https://chromiumdash.appspot.com/branches）
git checkout -b m120 refs/remotes/branch-heads/6099
# 更新完代码，对应的 toolchain 和 dependencies 也需要同步更新
gclient sync
```



### 修改代码

```c++
// 如果是 m94 版本需要修改代码 \src\modules\audio_device\win\audio_device_core_win.cc
// 第 2495 行
RTC_DCHECK(_hPlayThread);
// 改为
RTC_DCHECK(_hPlayThread == NULL);
```



### 编译

在命令行工具中运行下面的代码，编译 WebRTC：

```shell
cd %webrtc_src%\src

# m94 编译支持 h264 的 x64 debug 版本（非 clang）
gn gen out/x64H264Debug --ide=vs2019 --args="proprietary_codecs=true rtc_use_h264=true ffmpeg_use_unsafe_atomics=true ffmpeg_branding=\"Chrome\" is_debug=true target_cpu=\"x86\" rtc_include_tests=false target_os=\"win\" is_clang=false treat_warnings_as_errors=false use_rtti=true enable_iterator_debugging=true use_custom_libcxx=false use_lld=false rtc_build_ssl=false rtc_ssl_root=\"F:/OpenSSL1.1/OpenSSL-Win64/include\""
ninja -C out/x64H264Debug

# 编译支持 h264 的 x64 debug 版本
gn gen out/x64H264Debug --ide=vs2022 --ninja-executable=E:\webrtc\src\third_party\ninja\ninja.exe --args="proprietary_codecs=true rtc_use_h264=true ffmpeg_use_unsafe_atomics=true ffmpeg_branding=\"Chrome\" is_debug=true target_cpu=\"x64\" rtc_include_tests=false target_os=\"win\" is_clang=true treat_warnings_as_errors=false use_rtti=true enable_iterator_debugging=true use_custom_libcxx=false use_lld=false"
ninja -C out/x64H264Debug

# 编译支持 h264 的 x64 release 版本
gn gen out/x64H264Release --ide=vs2022 --ninja-executable=E:\webrtc\src\third_party\ninja\ninja.exe --args="proprietary_codecs=true rtc_use_h264=true ffmpeg_use_unsafe_atomics=true ffmpeg_branding=\"Chrome\" is_debug=false target_cpu=\"x64\" rtc_include_tests=false target_os=\"win\" is_clang=true treat_warnings_as_errors=false use_rtti=true enable_iterator_debugging=true use_custom_libcxx=false use_lld=false"
ninja -C out/x64H264Release

# haoxin hxrtc debug
gn gen out/Debug --ide=vs2022 --ninja-executable=D:\workspace\hxrtc\src\third_party\ninja\ninja.exe --args="is_debug=true target_cpu=\"x64\" rtc_use_h264=true rtc_use_h265=false is_clang=true enable_libaom=false gtest_enable_absl_printers=false libyuv_include_tests=false rtc_include_tests=false is_component_build=false rtc_enable_protobuf=true use_custom_libcxx=false use_custom_libcxx_for_host=false use_rtti=true treat_warnings_as_errors=false dcheck_always_on=false enable_iterator_debugging=true rtc_use_video_post_process=true rtc_use_video_pre_process=true rtc_enable_hx_transport=false"
ninja -C out/Debug

# 查看 gn 参数
gn args out/Default --list
```

**说明：**

- `proprietary_codecs`： 是否使用版权编码，也就是 H264，这里取 true。
- `rtc_use_h264`： 是否使用 H264，这里取 true，注意 Windows 平台编码使用 OpenH264，解码使用 ffmpeg。
- `ffmpeg_branding`： ffmpeg的分支名，这里采用Chrome的分支。
- `is_debug`： 是否开启 debug 模式
- `target_cpu`： 支持的cpu架构，Windows下可以取 x86、x64
- `target_os`： 支持的系统，可以取值 win、android、ios、linux 等，这里取win，表示 Windows 平台。
- `rtc_include_tests`： 自动编译单元测试test文件，默认是true，webrtc的单元测试文件很多，设置为false，可以节省不少编译时间。
- `is_clang`： 默认使用clang编译器，clang 编译器编译的话 msvc 无法正常使用。Windows 环境下为了支持 H264 编解码，需使用 clang 编译，ubuntu下 gcc编译，关闭。
- `use_custom_libcxx`： 默认libcxx的c++标准库，链接时会与vc++的libcxx冲突，使用 `use_custom_libcxx=false` 从而链接 vs++ 版本
- `use_rtti`： 默认 WebRTC 不开启 rtti，如果在代码中使用 typeid 将引起链接失败
- `enable_iterator_debugging`： 默认为 `false`，集成的时候如果不开启 debug 模式会报错【error LNK2038: 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项: 值“0”不匹配值“2”】，也可在工程中加入宏 `HAS_ITERATOR_DEBUGGING=0` 来解决。
- `is_component_build` ：是否使用动态运行期库，这里取false，使用静态运行期库，Release版本将对应MT，Debug版将对应MTd。
- `rtc_build_ssl`：是否编译BoringSSL，这里取false，因为后面我们要替换成OpenSSL。
- `rtc_ssl_root`：OpenSSL的头文件路径，会被写到生成的ninja文件中。
- `rtc_enable_protobuf`：是否编译 libprotobuf 。
- `use_lld` ：false，不使用 LLVM linker。
- **`ozone_platform_cast`**: 针对 Google Cast 设备的特定平台配置。

  **`ozone_platform_drm`**: 针对使用 DRM 的 Linux 平台的特定配置，常用于嵌入式和桌面 Linux 系统。

  **`ozone_platform_flatland`**: 针对 Google Fuchsia 操作系统的 Flatland 图形堆栈的特定配置。

  **`ozone_platform_headless`**: 适用于无图形界面的运行环境，主要用于后台任务、自动化测试和服务器端渲染。

  **`ozone_platform_wayland`**: 适用于支持 Wayland 图形服务器协议的现代系统，提供更高效和简洁的图形处理。

  **`ozone_platform_x11`**: 适用于支持 X11 图形服务器协议的系统，广泛应用于传统的 UNIX 和 Linux 系统上。



### 生成其他 lib

由于 webrtc.lib 中未包含的其他 obj，所以编译完 webrtc.lib 可能找不到 jsoncpp.lib 等库文件。可以使用下面的方法生成对应的 lib。

#### jsoncpp

```sh
lib /OUT:jsoncpp.lib third_party/jsoncpp/jsoncpp/json_reader.obj  third_party/jsoncpp/jsoncpp/json_value.obj  third_party/jsoncpp/jsoncpp/json_writer.obj
```



#### abseil-cpp

```sh
# 查找 obj 文件
dir /s /b E:\webrtc\src\out\Default\obj\third_party\abseil-cpp\absl\*.obj
# 生成 lib
lib /OUT:absl_other.lib third_party\abseil-cpp\absl\base\base\cycleclock.obj third_party\abseil-cpp\absl\base\base\spinlock.obj third_party\abseil-cpp\absl\base\base\sysinfo.obj third_party\abseil-cpp\absl\base\base\thread_identity.obj third_party\abseil-cpp\absl\base\base\unscaledcycleclock.obj third_party\abseil-cpp\absl\base\log_severity\log_severity.obj third_party\abseil-cpp\absl\base\malloc_internal\low_level_alloc.obj third_party\abseil-cpp\absl\base\raw_logging_internal\raw_logging.obj third_party\abseil-cpp\absl\base\spinlock_wait\spinlock_wait.obj third_party\abseil-cpp\absl\base\throw_delegate\throw_delegate.obj third_party\abseil-cpp\absl\container\hashtablez_sampler\hashtablez_sampler.obj third_party\abseil-cpp\absl\container\hashtablez_sampler\hashtablez_sampler_force_weak_definition.obj third_party\abseil-cpp\absl\container\raw_hash_set\raw_hash_set.obj third_party\abseil-cpp\absl\crc\cpu_detect\cpu_detect.obj third_party\abseil-cpp\absl\crc\crc32c\crc32c.obj third_party\abseil-cpp\absl\crc\crc32c\crc_memcpy_fallback.obj third_party\abseil-cpp\absl\crc\crc32c\crc_memcpy_x86_arm_combined.obj third_party\abseil-cpp\absl\crc\crc32c\crc_non_temporal_memcpy.obj third_party\abseil-cpp\absl\crc\crc_cord_state\crc_cord_state.obj third_party\abseil-cpp\absl\crc\crc_internal\crc.obj third_party\abseil-cpp\absl\crc\crc_internal\crc_x86_arm_combined.obj third_party\abseil-cpp\absl\debugging\debugging_internal\address_is_readable.obj third_party\abseil-cpp\absl\debugging\debugging_internal\elf_mem_image.obj third_party\abseil-cpp\absl\debugging\debugging_internal\vdso_support.obj third_party\abseil-cpp\absl\debugging\demangle_internal\demangle.obj third_party\abseil-cpp\absl\debugging\stacktrace\stacktrace.obj third_party\abseil-cpp\absl\debugging\symbolize\symbolize.obj third_party\abseil-cpp\absl\flags\commandlineflag\commandlineflag.obj third_party\abseil-cpp\absl\flags\commandlineflag_internal\commandlineflag.obj third_party\abseil-cpp\absl\flags\config\usage_config.obj third_party\abseil-cpp\absl\flags\flag\flag.obj third_party\abseil-cpp\absl\flags\flag_internal\flag.obj third_party\abseil-cpp\absl\flags\marshalling\marshalling.obj third_party\abseil-cpp\absl\flags\parse\parse.obj third_party\abseil-cpp\absl\flags\private_handle_accessor\private_handle_accessor.obj third_party\abseil-cpp\absl\flags\program_name\program_name.obj third_party\abseil-cpp\absl\flags\reflection\reflection.obj third_party\abseil-cpp\absl\flags\usage\usage.obj third_party\abseil-cpp\absl\flags\usage_internal\usage.obj third_party\abseil-cpp\absl\hash\city\city.obj third_party\abseil-cpp\absl\hash\hash\hash.obj third_party\abseil-cpp\absl\hash\low_level_hash\low_level_hash.obj third_party\abseil-cpp\absl\numeric\int128\int128.obj third_party\abseil-cpp\absl\profiling\exponential_biased\exponential_biased.obj third_party\abseil-cpp\absl\strings\cord\cord.obj third_party\abseil-cpp\absl\strings\cord\cord_analysis.obj third_party\abseil-cpp\absl\strings\cord\cord_buffer.obj third_party\abseil-cpp\absl\strings\cordz_functions\cordz_functions.obj third_party\abseil-cpp\absl\strings\cordz_handle\cordz_handle.obj third_party\abseil-cpp\absl\strings\cordz_info\cordz_info.obj third_party\abseil-cpp\absl\strings\cord_internal\cord_internal.obj third_party\abseil-cpp\absl\strings\cord_internal\cord_rep_btree.obj third_party\abseil-cpp\absl\strings\cord_internal\cord_rep_btree_navigator.obj third_party\abseil-cpp\absl\strings\cord_internal\cord_rep_btree_reader.obj third_party\abseil-cpp\absl\strings\cord_internal\cord_rep_consume.obj third_party\abseil-cpp\absl\strings\cord_internal\cord_rep_crc.obj third_party\abseil-cpp\absl\strings\internal\escaping.obj third_party\abseil-cpp\absl\strings\internal\ostringstream.obj third_party\abseil-cpp\absl\strings\internal\utf8.obj third_party\abseil-cpp\absl\strings\strings\ascii.obj third_party\abseil-cpp\absl\strings\strings\charconv.obj third_party\abseil-cpp\absl\strings\strings\charconv_bigint.obj third_party\abseil-cpp\absl\strings\strings\charconv_parse.obj third_party\abseil-cpp\absl\strings\strings\damerau_levenshtein_distance.obj third_party\abseil-cpp\absl\strings\strings\escaping.obj third_party\abseil-cpp\absl\strings\strings\match.obj third_party\abseil-cpp\absl\strings\strings\memutil.obj third_party\abseil-cpp\absl\strings\strings\numbers.obj third_party\abseil-cpp\absl\strings\strings\stringify_sink.obj third_party\abseil-cpp\absl\strings\strings\str_cat.obj third_party\abseil-cpp\absl\strings\strings\str_replace.obj third_party\abseil-cpp\absl\strings\strings\str_split.obj third_party\abseil-cpp\absl\strings\strings\substitute.obj third_party\abseil-cpp\absl\strings\string_view\string_view.obj third_party\abseil-cpp\absl\strings\str_format_internal\arg.obj third_party\abseil-cpp\absl\strings\str_format_internal\bind.obj third_party\abseil-cpp\absl\strings\str_format_internal\extension.obj third_party\abseil-cpp\absl\strings\str_format_internal\float_conversion.obj third_party\abseil-cpp\absl\strings\str_format_internal\output.obj third_party\abseil-cpp\absl\strings\str_format_internal\parser.obj third_party\abseil-cpp\absl\synchronization\graphcycles_internal\graphcycles.obj third_party\abseil-cpp\absl\synchronization\kernel_timeout_internal\kernel_timeout.obj third_party\abseil-cpp\absl\synchronization\synchronization\barrier.obj third_party\abseil-cpp\absl\synchronization\synchronization\blocking_counter.obj third_party\abseil-cpp\absl\synchronization\synchronization\create_thread_identity.obj third_party\abseil-cpp\absl\synchronization\synchronization\futex_waiter.obj third_party\abseil-cpp\absl\synchronization\synchronization\mutex.obj third_party\abseil-cpp\absl\synchronization\synchronization\notification.obj third_party\abseil-cpp\absl\synchronization\synchronization\per_thread_sem.obj third_party\abseil-cpp\absl\synchronization\synchronization\pthread_waiter.obj third_party\abseil-cpp\absl\synchronization\synchronization\sem_waiter.obj third_party\abseil-cpp\absl\synchronization\synchronization\stdcpp_waiter.obj third_party\abseil-cpp\absl\synchronization\synchronization\waiter_base.obj third_party\abseil-cpp\absl\synchronization\synchronization\win32_waiter.obj third_party\abseil-cpp\absl\time\internal\cctz\civil_time\civil_time_detail.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_fixed.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_format.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_if.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_impl.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_info.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_libc.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_lookup.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\time_zone_posix.obj third_party\abseil-cpp\absl\time\internal\cctz\time_zone\zone_info_source.obj third_party\abseil-cpp\absl\time\time\civil_time.obj third_party\abseil-cpp\absl\time\time\clock.obj third_party\abseil-cpp\absl\time\time\duration.obj third_party\abseil-cpp\absl\time\time\format.obj third_party\abseil-cpp\absl\time\time\time.obj third_party\abseil-cpp\absl\types\bad_optional_access\bad_optional_access.obj third_party\abseil-cpp\absl\types\bad_variant_access\bad_variant_access.obj
```



#### rtc_base

```sh
# 查找 obj 文件
dir /s /b E:\webrtc\src\out\Default\obj\rtc_base\*.obj
# 生成 lib
lib /OUT:rtc_base_other.lib rtc_base\async_dns_resolver\async_dns_resolver.obj rtc_base\async_packet_socket\async_packet_socket.obj rtc_base\async_resolver_interface\async_resolver_interface.obj rtc_base\async_socket\async_socket.obj rtc_base\async_tcp_socket\async_tcp_socket.obj rtc_base\async_udp_socket\async_udp_socket.obj rtc_base\audio_format_to_string\audio_format_to_string.obj rtc_base\bitrate_tracker\bitrate_tracker.obj rtc_base\bitstream_reader\bitstream_reader.obj rtc_base\bit_buffer\bit_buffer.obj rtc_base\buffer_queue\buffer_queue.obj rtc_base\byte_buffer\byte_buffer.obj rtc_base\callback_list\callback_list.obj rtc_base\checks\checks.obj rtc_base\containers\flat_containers_internal\flat_tree.obj rtc_base\copy_on_write_buffer\copy_on_write_buffer.obj rtc_base\crc32\crc32.obj rtc_base\criticalsection\recursive_critical_section.obj rtc_base\crypt_string\crypt_string.obj rtc_base\event_tracer\event_tracer.obj rtc_base\experiments\alr_experiment\alr_experiment.obj rtc_base\experiments\balanced_degradation_settings\balanced_degradation_settings.obj rtc_base\experiments\bandwidth_quality_scaler_settings\bandwidth_quality_scaler_settings.obj rtc_base\experiments\cpu_speed_experiment\cpu_speed_experiment.obj rtc_base\experiments\encoder_info_settings\encoder_info_settings.obj rtc_base\experiments\field_trial_parser\field_trial_list.obj rtc_base\experiments\field_trial_parser\field_trial_parser.obj rtc_base\experiments\field_trial_parser\field_trial_units.obj rtc_base\experiments\field_trial_parser\struct_parameters_parser.obj rtc_base\experiments\keyframe_interval_settings_experiment\keyframe_interval_settings.obj rtc_base\experiments\min_video_bitrate_experiment\min_video_bitrate_experiment.obj rtc_base\experiments\normalize_simulcast_size_experiment\normalize_simulcast_size_experiment.obj rtc_base\experiments\quality_rampup_experiment\quality_rampup_experiment.obj rtc_base\experiments\quality_scaler_settings\quality_scaler_settings.obj rtc_base\experiments\quality_scaling_experiment\quality_scaling_experiment.obj rtc_base\experiments\rate_control_settings\rate_control_settings.obj rtc_base\experiments\rtt_mult_experiment\rtt_mult_experiment.obj rtc_base\experiments\stable_target_rate_experiment\stable_target_rate_experiment.obj rtc_base\frequency_tracker\frequency_tracker.obj rtc_base\histogram_percentile_counter\histogram_percentile_counter.obj rtc_base\http_common\http_common.obj rtc_base\ip_address\ip_address.obj rtc_base\logging\logging.obj rtc_base\memory\aligned_malloc\aligned_malloc.obj rtc_base\memory\fifo_buffer\fifo_buffer.obj rtc_base\network\network.obj rtc_base\network\received_packet\received_packet.obj rtc_base\network\sent_packet\sent_packet.obj rtc_base\network_constants\network_constants.obj rtc_base\network_route\network_route.obj rtc_base\net_helper\net_helper.obj rtc_base\net_helpers\net_helpers.obj rtc_base\null_socket_server\null_socket_server.obj rtc_base\platform_thread\platform_thread.obj rtc_base\platform_thread_types\platform_thread_types.obj rtc_base\proxy_info\proxy_info.obj rtc_base\race_checker\race_checker.obj rtc_base\random\random.obj rtc_base\rate_limiter\rate_limiter.obj rtc_base\rate_statistics\rate_statistics.obj rtc_base\rate_tracker\rate_tracker.obj rtc_base\rtc_base_tests_utils\cpu_time.obj rtc_base\rtc_base_tests_utils\fake_clock.obj rtc_base\rtc_base_tests_utils\fake_ssl_identity.obj rtc_base\rtc_base_tests_utils\firewall_socket_server.obj rtc_base\rtc_base_tests_utils\memory_stream.obj rtc_base\rtc_base_tests_utils\memory_usage.obj rtc_base\rtc_base_tests_utils\nat_server.obj rtc_base\rtc_base_tests_utils\nat_socket_factory.obj rtc_base\rtc_base_tests_utils\nat_types.obj rtc_base\rtc_base_tests_utils\proxy_server.obj rtc_base\rtc_base_tests_utils\server_socket_adapters.obj rtc_base\rtc_base_tests_utils\socket_stream.obj rtc_base\rtc_base_tests_utils\test_echo_server.obj rtc_base\rtc_base_tests_utils\test_utils.obj rtc_base\rtc_base_tests_utils\virtual_socket_server.obj rtc_base\rtc_certificate_generator\rtc_certificate_generator.obj rtc_base\rtc_event\event.obj rtc_base\rtc_json\json.obj rtc_base\rtc_numerics\event_based_exponential_moving_average.obj rtc_base\rtc_numerics\exp_filter.obj rtc_base\rtc_numerics\moving_average.obj rtc_base\rtc_operations_chain\operations_chain.obj rtc_base\rtc_task_queue\task_queue.obj rtc_base\rtc_task_queue_win\task_queue_win.obj rtc_base\sample_counter\sample_counter.obj rtc_base\socket\socket.obj rtc_base\socket_adapters\socket_adapters.obj rtc_base\socket_address\socket_address.obj rtc_base\socket_address_pair\socket_address_pair.obj rtc_base\ssl\boringssl_certificate.obj rtc_base\ssl\boringssl_identity.obj rtc_base\ssl\helpers.obj rtc_base\ssl\message_digest.obj rtc_base\ssl\openssl_adapter.obj rtc_base\ssl\openssl_digest.obj rtc_base\ssl\openssl_key_pair.obj rtc_base\ssl\openssl_session_cache.obj rtc_base\ssl\openssl_stream_adapter.obj rtc_base\ssl\openssl_utility.obj rtc_base\ssl\rtc_certificate.obj rtc_base\ssl\ssl_adapter.obj rtc_base\ssl\ssl_certificate.obj rtc_base\ssl\ssl_fingerprint.obj rtc_base\ssl\ssl_identity.obj rtc_base\ssl\ssl_stream_adapter.obj rtc_base\stream\stream.obj rtc_base\stringutils\string_builder.obj rtc_base\stringutils\string_encode.obj rtc_base\stringutils\string_format.obj rtc_base\stringutils\string_to_number.obj rtc_base\stringutils\string_utils.obj rtc_base\synchronization\sequence_checker_internal\sequence_checker_internal.obj rtc_base\synchronization\yield\yield.obj rtc_base\synchronization\yield_policy\yield_policy.obj rtc_base\system\file_wrapper\file_wrapper.obj rtc_base\task_utils\repeating_task\repeating_task.obj rtc_base\third_party\base64\base64\base64.obj rtc_base\third_party\sigslot\sigslot\sigslot.obj rtc_base\threading\async_resolver.obj rtc_base\threading\default_socket_server.obj rtc_base\threading\network_monitor.obj rtc_base\threading\network_monitor_factory.obj rtc_base\threading\physical_socket_server.obj rtc_base\threading\thread.obj rtc_base\timestamp_aligner\timestamp_aligner.obj rtc_base\timeutils\system_time.obj rtc_base\timeutils\time_utils.obj rtc_base\unique_id_generator\unique_id_generator.obj rtc_base\weak_ptr\weak_ptr.obj rtc_base\win\create_direct3d_device\create_direct3d_device.obj rtc_base\win\get_activation_factory\get_activation_factory.obj rtc_base\win\hstring\hstring.obj rtc_base\win\scoped_com_initializer\scoped_com_initializer.obj rtc_base\win\windows_version\windows_version.obj rtc_base\win32\win32.obj rtc_base\zero_memory\zero_memory.obj
```



#### test

```sh
# 查找 obj 文件
dir /s /b E:\webrtc\src\out\Default\obj\test\*.obj
# 生成 lib
lib /OUT:webrtc_test.lib test\create_frame_generator_capturer\create_frame_generator_capturer.obj test\fake_video_codecs\configurable_frame_size_encoder.obj test\fake_video_codecs\fake_decoder.obj test\fake_video_codecs\fake_encoder.obj test\fake_video_codecs\fake_vp8_decoder.obj test\fake_video_codecs\fake_vp8_encoder.obj test\field_trial\field_trial.obj test\fileutils\file_utils.obj test\fileutils_override_impl\file_utils_override.obj test\frame_generator_capturer\frame_generator_capturer.obj test\frame_generator_impl\frame_generator.obj test\frame_generator_impl\ivf_video_frame_generator.obj test\frame_utils\frame_utils.obj test\perf_test\perf_test.obj test\perf_test\perf_test_histogram_writer.obj test\platform_video_capturer\platform_video_capturer.obj test\platform_video_capturer\vcm_capturer.obj test\rtp_test_utils\rtcp_packet_parser.obj test\rtp_test_utils\rtp_file_reader.obj test\rtp_test_utils\rtp_file_writer.obj test\scoped_key_value_config\scoped_key_value_config.obj test\test_video_capturer\test_video_capturer.obj test\video_test_common\fake_texture_frame.obj test\video_test_common\frame_forwarder.obj test\video_test_common\mappable_native_buffer.obj
```



### 常见错误及解决

#### CONFIG_PCM_VIDC_ENCODER 未声明的标识符

对于 m94 版本，会出现很多错误，这里统一说明一下如何修改。

```
…/…/third_party/ffmpeg/libavcodec/pcm.c(52): error C2065: “CONFIG_PCM_VIDC_ENCODER”: 未声明的标识符
…/…/third_party/ffmpeg/libavcodec/pcm.c(634): error C2059: 语法错误:“字符串”
```

解决方法：

1. 直接将对应的行代码注释掉

2. 添加对应的宏定义

   ```
   third_party\ffmpeg\chromium\config\Chrome\win-msvc\ia32\config.h:
   （文件根据平台的实际情况）在倒数第2行添加：
   #define CONFIG_PCM_VIDC_DECODER 0
   #define CONFIG_PCM_VIDC_ENCODER 0
   #define CONFIG_VP4_DECODER 0
   
   third_party\ffmpeg\libavcodec\pcm.c
   注释最后一行
   // PCM_DECODER(PCM_SGA,          AV_SAMPLE_FMT_U8,  pcm_sga,          "PCM SGA");
   
   modules/video_coding/codecs/h264/h264_decoder_impl.h
   modules/video_coding/codecs/h264/h264_color_space.h
   modules/video_coding/codecs/h264/h264_encoder_impl.h
   对于上面的三个文件，注释
   //#error "See: bugs.webrtc.org/9213#c13."
   ```



#### error C2589: “(”: “::”右边的非法标记

```
error C2589: “(”: “::”右边的非法标记
error C2059: 语法错误 : “::”
```

**原因**：

**函数模板max**与Visual C++中的全局的**宏max\**\**冲突**。

解决办法：

设置项目属性，在预定义处理器中添加定义NOMINMAX来禁止使用Visual C++的min/max宏定义。
项目属性 ——> C/C++ ——> 预处理器 ——> 预处理器定义 (此处添加预定义编译开关 NOMINMAX）
但是visual C++中定义能自动匹配double和int，如果进行了上述设置，代码中手动将int型的数据乘以1.0来达到double的目的。

加上括号，与Vsual C++的min/max宏定义区分开
举个栗子：

```c++
// 原始
float data_max = std::max(a1,a2);
// 修改为
float data_max = (std::max)(a1,a2);
```



#### windows运行webrtc的PeerConnectionClient连接问题修复

win10 vs2022时，运行PeerConnectionClient，使用本地ip连接PeerConnectionServer时，PeerConnectionClient的onConnect没有回调。经过分析，是由于main.cc定义的线程没有运行

```
rtc::AutoSocketServerThread main_thread(&ss);
```

需要在 peer_connection_client.cc 中的方法 PeerConnectionClient::DoConnect() 添加逻辑，在方法最后添加

```
rtc::Thread::Current()->Start();
```

另外还有个线程死等的问题，要修改 rtc_base\physical_socket_server.cc 中的 Wait 方法

```
DWORD dw =
        WSAWaitForMultipleEvents(static_cast<DWORD>(events.size()), &events[0],
                                 false, static_cast<DWORD>(cmsNext+2000), false);
```



### 提取头文件

将下面的内容保存为批处理文件 *extrac_webrtc_headers.bat* 并执行：

```bat
echo off

::该脚本必须放在webrtc源码src目录的上一级目录

:: 创建目标目录
mkdir include

::定义源目录
set srcpath=.\src
::定义目标路径
set dstpath=.\include

:: /s 复制目录和子目录，除了空的。
:: /e 复制目录和子目录，包括空的。 
:: /y 禁止提示以确认改写一个现存目标文件。
:: /c 即使有错误也继续执行
:: /h 也复杂隐藏文件和系统文件
:: /r 覆盖只读文件
xcopy %srcpath%\*.h %dstpath%\ /s /e /c /y /h /r

pause
```



## Linux 平台

### 下载源码

下载源码前首先配置代理服务器，打开命令行输入下面命令：

```shell
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890
export http_proxy=http://127.0.0.1:7890
export https_proxy=http://127.0.0.1:7890
```

然后安装 `depot tools`：

```shell
cd %webrtc_src%
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
```

安装完成后加入环境变量，重新打开命令行，执行 `gclient`，它会自动下载所需要的第三方应用，例如：python 等。

可以执行下列命令设置临时环境变量，但是只在当前控制台生效：

```shell
export PATH=$PATH:%webrtc_src%/depot_tools
export PATH=~/depot_tools:$PATH
```

也可以将上面那句话加入到 `/etc/profile` 中，然后执行 `source /etc/profile` 命令。

````shell
gclient
````

前期准备完成后就可以获取 WebRTC 源代码了，在命令行中工具执行下面的代码：

```shell
cd %webrtc_src%
mkdir webrtc-checkout
cd webrtc-checkout
fetch --nohooks webrtc
gclient sync
cd src
# 切换到 libmediasoupclient 依赖的 m94 版本
# git checkout -b m94 refs/remotes/branch-heads/4606
# 或者切换到 m120 版本（分支对应的版本详见：https://chromiumdash.appspot.com/branches）
git checkout -b m120 refs/remotes/branch-heads/6099
# 更新完代码，对应的 toolchain 和 dependencies 也需要同步更新
gclient sync
```



### 编译

在命令行工具中运行下面的代码，编译 WebRTC：

```sh
sudo apt install g++ git pkg-config
sudo apt install libglib2.0-dev
sudo apt install libx11-dev
sudo apt install libgtk-3-dev

# gcc编译x64版
gn gen out/Default --args='target_os="linux" target_cpu="x64" is_debug=false is_component_build=false use_sysroot=false is_clang=false use_lld=false rtc_use_h264=true treat_warnings_as_errors=false rtc_include_tests=false rtc_build_examples=false rtc_build_tools=false use_custom_libcxx=false use_rtti=true rtc_enable_protobuf=false'
autoninja -C out/Default

# test
gn gen out/Default --args='target_os="linux" target_cpu="x64" is_debug=false ffmpeg_branding="Chrome" is_component_build=false use_sysroot=false is_clang=false use_lld=false rtc_use_h264=true treat_warnings_as_errors=false rtc_include_tests=false rtc_build_examples=false rtc_build_tools=false use_custom_libcxx=false use_custom_libcxx_for_host=false use_rtti=true rtc_enable_protobuf=false enable_libaom=false gtest_enable_absl_printers=false libyuv_include_tests=false'
autoninja -C out/Default

# haoxin
gn gen out/Debug --args='target_os="linux" target_cpu="x64" is_debug=true is_component_build=false use_sysroot=false is_clang=false use_lld=false rtc_use_h264=true treat_warnings_as_errors=false rtc_include_tests=false rtc_build_examples=false rtc_build_tools=false use_custom_libcxx=false use_custom_libcxx_for_host=false use_rtti=true rtc_enable_protobuf=false enable_libaom=false gtest_enable_absl_printers=false libyuv_include_tests=false rtc_enable_protobuf=true rtc_enable_grpc=true rtc_use_video_post_process=false rtc_use_video_pre_process=false rtc_enable_hx_transport=true rtc_use_x11=false'
autoninja -C out/Debug
```

**说明：**

- `target_cpu`： 支持的cpu架构，Linux 下可以取 x86_64



### 常见错误及解决

#### RPC FAILED； RESULT=18, HTTP CODE = 200

```
error: RPC failed; result=18, HTTP code = 200
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
```

因为 git 库上面放了一些数据,所以整个库较大。是 curl 的 postBuffer 默认值较小的原因，配置下个这个值：

```bash
git config --global http.postBuffer 1024288000
git config --list
```



#### version `GLIBCXX_3.4.22' not found

检查版本：

```
strings /lib64/libstdc++.so.6 | grep GLIBCX
```



#### /lib64/libc.so.6: version `GLIBC_2.18' not found 

```
# 下载 glibc_2.18 
wget http://mirrors.ustc.edu.cn/gnu/libc/glibc-2.18.tar.gz
configure出错：configure: error:
*** These critical programs are missing or too old: gcc
*** Check the INSTALL file for required versions.
```


这个问题处理起来有点麻烦，我选择编译webrtc时避免使用glibc这个库。`use_glib=false`



#### 找不到各种头文件错误

```sh
# alsa/asoundlib.h: No such file or directory
sudo yum install alsa-lib-devel
sudo apt install libasound2-dev

# pulse/pulseaudio.h: No such file or directory
sudo yum install pulseaudio-libs-devel
sudo apt install libpulse-dev

# X11/extensions/XShm.h: No such file or directory
sudo yum install libXext-devel
sudo apt install libxext-dev

# X11/extensions/XTest.h: No such file or directory
sudo yum install libXtst-devel
sudo apt install libxtst-dev

# X11/extensions/Xdamage.h: No such file or directory
sudo yum install libXdamage-devel
sudo apt install libxdamage-dev

# X11/extensions/Xrandr.h: No such file or directory
sudo yum install libXrandr-devel
sudo apt install libxrandr-dev

# X11/extensions/Xcomposite.h: No such file or directory
sudo apt install libxcomposite-dev
```



下面是在CentOS上编译的过程：

```sh
export http_proxy=http://192.168.0.160:7890
export https_proxy=http://192.168.0.160:7890
git config --global http.proxy http://192.168.0.160:7890
git config --global https.proxy http://192.168.0.160:7890
export PATH=$PATH:/home/cjx/webrtc_src/depot_tools
export PATH=/home/cjx/webrtc_src/webrtc-checkout/src/third_party/depot_tools:$PATH

sudo /var/lib/snapd/snap/bin/patchelf --set-interpreter /opt/glibc-2.37/lib/ld-linux-x86-64.so.2 --set-rpath /opt/glibc-2.37/lib:/usr/lib64  /home/cjx/webrtc_src/webrtc-checkout/src/buildtools/linux64/gn
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/glibc-2.37/lib

开始以为就是符号找不到，怎么改都无果。而且报的都是类型未定义，不是具体方法未定义，都发生在类继承的时候。后发现是webrtc编译关了rtti，打开即可：
gn gen out/mybuild-m74 --args='is_debug=false is_component_build=false is_clang=false rtc_include_tests=false rtc_use_h264=true rtc_enable_protobuf=false use_rtti=true use_custom_libcxx=false treat_warnings_as_errors=false use_ozone=true rtc_enable_protobuf=false'

https://blog.csdn.net/thehunters/article/details/124092439

https://juejin.cn/post/7040371168897368072


 cmake . -Bbuild \
  -DLIBWEBRTC_INCLUDE_PATH:PATH=/home/cjx/webrtc_src/webrtc-checkout/src \
  -DLIBWEBRTC_BINARY_PATH:PATH=/home/cjx/webrtc_src/webrtc-checkout/src/out/Default/obj
  
 make -C build/
```



### 提取头文件

要复制一个文件夹及其子文件夹中所有扩展名为 .h 的文件，可以使用 `find` 命令来查找这些文件，然后使用 `cp` 命令进行复制。下面是一种方法：

```sh
find /path/to/your/directory -type f -name "*.h" -exec cp --parents {} /path/to/destination/ \;

zip -r 压缩包名称.zip 文件夹名称
```

其中：

- `find /path/to/source/dir` 从指定的源目录开始查找
- `-name "*.h"` 查找匹配模式 `*.h` 的文件
- `-exec cp --parents '{}' /path/to/target/dir \;` 对于找到的每个文件,使用 `cp` 命令将其复制到目标目录,`--parents`选项保留源文件相对于源目录的路径结构
- `'{}'` 是一个特殊的字符串,代表当前找到的文件的完整路径
- `\;` 是对 `-exec` 选项的结束标记

请将 `/path/to/your/directory` 替换为你要复制文件的目录路径，将 `/path/to/destination/` 替换为你要复制到的目标目录路径。

这条命令会在指定的目录中查找所有扩展名为 `.h` 的文件，并将它们复制到指定的目标目录中。



### 提取库文件

要复制一个文件夹及其子文件夹中所有扩展名为 .a 的文件，可以使用 `find` 命令来查找这些文件，然后使用 `cp` 命令进行复制。下面是一种方法：

```
find /path/to/your/directory -type f -name "*.a" -exec cp -r {} /path/to/destination/ \;
```

请将 `/path/to/your/directory` 替换为你要复制文件的目录路径，将 `/path/to/destination/` 替换为你要复制到的目标目录路径。

该命令在 `find` 命令中添加了 `-type f` 选项，该选项指定只查找文件。这样，`cp -r` 命令只会复制文件，而不会复制目录，让所有库文件都在一个目录下。



## macOS 平台

### 下载源码

首先我们需要下载 WebRTC iOS/macOS 的代码库，以及相关的编译依赖，而这需要我们先下载安装 depot tools。depot tools 是 Chromium 代码库管理工具，提供了代码管理、依赖管理、工作流程管理等功能，运行 depot tools 需要 Python 2.x 环境，而且需要是官方 build(--version 选项不能输出额外信息，macOS 系统自带的 Python 环境就是 2.x，没有问题，但如果使用 virtualenv 或 conda 等工具管理系统的 Python 环境,就需要把当前环境的Pvthon可执行文件链接到系统的 Python 程序上去)。
下载 depot tools 和 WebRTC iOS/macOS 代码的命令如下：

```sh
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
export PATH=$PATH:<depot_tools clone 到本地的路径>
# cd 到希望放置 webRTc ios/macos 代码库的目录中
# 注意，对于 macOS 和 iOS 都是 webrtc_ios。即，既不是 webrtc 也不是 webrtc_mac 。
fetch --nohooks webrtc_ios
#上条命令执行完毕后，可以编辑当前目录下的 .gclient 文件
# 在 target os 里加上 mac，这套代码就可以用于 macos 开发了
gclient sync

cd src
# 切换分支
# git checkout -b m94 refs/remotes/branch-heads/4606
# 切换分支还再次 sync
gclient sync
```



### 编译

```sh
# 编译 m94 
# 最新版本的 Xcode 不兼容。 在 macOS 14/Xcode 13.2.1(MacOSX12.1.sdk) 下编译，需要下载一个旧版本的 Xcode 并切换版本
# sudo xcode-select --switch /Applications/Xcode-13.4.0.app/
# sudo xcode-select -p
gn gen out/m94 --args='is_debug=false is_component_build=false is_clang=true rtc_include_tests=false rtc_use_h264=true use_rtti=true treat_warnings_as_errors=false mac_deployment_target="10.11" use_custom_libcxx=false rtc_build_tools=false rtc_build_examples=true'
ninja -C out/m94

gn gen out/mac --ide=xcode --args='is_debug=false target_os="mac" target_cpu="arm64" is_component_build=false is_clang=true rtc_include_tests=false rtc_use_h264=true use_rtti=true enable_dsyms=true use_custom_libcxx=false treat_warnings_as_errors=false rtc_build_tools=false rtc_build_examples=true'
ninja -C out/mac
```

**说明：**

- `target_cpu`： 支持的cpu架构，macOS 下可以取 arm64、x64；
- `target_os`： 支持的系统，可以取值 win、android、ios、linux 等，这里取 mac，表示 macOS 平台。
- `enable_dsyms`: true，生成 debug symbols，配合 is_debug=true 使用；
- `rtc_enable_objc_symbol_export`：将其设置为 true 会使 RTC_OBJC_EXPORT 扩展为管理符号可见性的代码。默认情况下，如果 C++ 符号被导出，Obj-C/Obj-C++ 符号也会被导出。但如果将此参数设置为 true 并且保持 rtc_enable_symbol_export=false，则只有带有 RTC_OBJC_EXPORT 注释的符号会被导出。
- `mac_deployment_target`：指定编译 WebRTC 项目时的目标 macOS 版本。例如，如果设置 `mac_deployment_target=10.14`，那么编译生成的二进制文件将保证能够在 macOS 10.14 及更高版本上运行。



## iOS 平台

iOS 下载过程同 macOS 平台。

```sh
gn gen out/Default --ide=xcode --args='is_debug=false target_os="ios" target_cpu="arm64" target_environment="device" ios_deployment_target="12.0" ios_code_signing_identity="B162513579370BD88824E510B4A8A95C990BCF95" ios_code_signing_identity_description="" ios_enable_code_signing=true is_component_build=false is_clang=true use_lld=true use_goma=false use_remoteexec=false rtc_enable_objc_symbol_export=true enable_dsyms=true enable_stripping=true rtc_include_tests=false rtc_use_h264=true use_rtti=true use_custom_libcxx=false treat_warnings_as_errors=false rtc_build_tools=false rtc_build_examples=true'
ninja -C out/Default
```

**说明：**

- `ios_deployment_target`：指定编译 WebRTC 项目时的目标 iOS 版本。例如，如果设置 `ios_deployment_target=12.0`，那么编译生成的二进制文件将保证能够在 iOS 12.0 及更高版本上运行。
- `target_environment`：iOS 目标环境， "simulator" 或者 "device"。
- `ios_code_signing_identity`: iOS 开发者账号的 identity。每一个开发者帐号都会有一个 identify，可以通过 `xcrun security find-identity -v -p codesigning` 命令查看本机所有的 identity



## Android 平台

WebRTC m120 版本只支持在 Linux 系统下编译 Android 平台。 

### 下载源码

下载源码前首先配置代理服务器，打开命令行输入下面命令：

```shell
git config --global http.proxy http://192.168.5.160:7890
git config --global https.proxy http://192.168.5.160:7890
export http_proxy=http://192.168.5.160:7890
export https_proxy=http://192.168.5.160:7890

git config --global http.sslVerify false
```

然后安装 `depot tools`：

```shell
cd %webrtc_src%
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
```

安装完成后加入环境变量，重新打开命令行，执行 `gclient`，它会自动下载所需要的第三方应用，例如：*python* 等。

可以执行下列命令设置临时环境变量，但是只在当前控制台生效：

```shell
export PATH=$PATH:%webrtc_src%/depot_tools
```

也可以将上面那句话加入到 `/etc/profile` 中，然后执行 `source /etc/profile` 命令。

````shell
gclient
````

前期准备完成后就可以获取 WebRTC 源代码了，在命令行中工具执行下面的代码：

```shell
cd %webrtc_src%
mkdir webrtc_android
cd webrtc_android
fetch --nohooks webrtc_android
gclient sync

cd src
# 切换到 libmediasoupclient 依赖的 m94 版本
# git checkout -b m94 refs/remotes/branch-heads/4606
# 或者切换到 m120 版本（分支对应的版本详见：https://chromiumdash.appspot.com/branches）
git checkout -b m120 refs/remotes/branch-heads/6099
# 更新完代码，对应的 toolchain 和 dependencies 也需要同步更新
gclient sync
```



### ~~安装依赖~~

```sh
cd src
./build/install-build-deps.sh
. build/android/envsetup.sh
```



### 编译

```sh
gn gen out/android_64 --args='target_os="android" target_cpu="x64" is_debug=false'
ninja -C out/android_64
gn gen out/android_arm64 --args='target_os="android" target_cpu="arm64" is_debug=false rtc_use_h264=true treat_warnings_as_errors=false rtc_include_tests=false rtc_build_tools=false rtc_enable_protobuf=false enable_libaom=false gtest_enable_absl_printers=false libyuv_include_tests=false rtc_build_examples=true'
ninja -C out/android_arm64
# 只编译 AppRTCMobile 及其依赖
ninja -C out/android_64 AppRTCMobile

# haoxin hxrtc debug
export PATH=~/depot_tools:$PATH
gn gen out/android_arm64 --args='target_os="android" target_cpu="arm64" is_debug=true enable_iterator_debugging=true rtc_use_h264=true treat_warnings_as_errors=false rtc_include_tests=false rtc_build_tools=false rtc_enable_protobuf=false enable_libaom=false gtest_enable_absl_printers=false libyuv_include_tests=false rtc_build_examples=true'
ninja -C out/android_arm64
```



### 生成 Android Studio 工程

编译完成后，生成 Android Studio 工程所需的 gradle 文件。

```sh
build/android/gradle/generate_gradle.py --output-directory out/android_arm64 --target "//examples:AppRTCMobile" --use-gradle-process-resources --split-projects
```

编译完成后，输出的工程项目文件在 *src\out\android_arm64\gradle*  目录。



### 常见错误及解决

#### undefined reference to '_Unwind_Backtrace'

当 gn 命令使用 `use_custom_libcxx=false` 参数时，出现下列错误，这个错误一般出现在 Ubuntu 22 系统。

```
# error: undefined reference to '_Unwind_Backtrace'
# error: undefined reference to '_Unwind_GetIP'
```

修改代码：

1. 修改 *src/buildtools/third_party/libunwind/BUILD.gn*文件

   ```
   # 在下列段落中
   source_set("libunwind") {
     ...
   }
   
   # 添加 visibility 参数
   source_set("libunwind") {
     visibility = ["//build/config:common_deps"]
     ...
   }
   ```

2. 修改 *src/build/config/BUILD.gn* 文件

   ```
   if (use_custom_libcxx) {
     public_deps += [ "//buildtools/third_party/libc++" ]
   }
   # 修改为
   if (use_custom_libcxx) {
     public_deps += [ "//buildtools/third_party/libc++" ]
   } else {
     public_deps += [ "//buildtools/third_party/libunwind" ]
   }
   ```

问题参考网址： https://bugs.chromium.org/p/webrtc/issues/detail?id=13535、https://www.jianshu.com/p/e36e2a25ac25



#### 找不到 org.webrtc.VideoDecoder 的类文件

如果在 m120 出现 `找不到 org.webrtc.VideoDecoder 的类文件` 错误，则在 *sdk.android.dav1d_java* 项目的 *build.gradle* 文件的 `java.filter.exclude` 节添加

`"org/webrtc/Dav1dDecoder.java"` 。

```
java.filter.exclude([
    ...
    "org/webrtc/Dav1dDecoder.java",
    ...
])
```



#### Fatal error: dlopen failed: library "libjingle_peerconnection_so.so" not found

将动态库文件放置在正确的目录中：

1. 在 Android Studio 工程中，有一个名为 `jniLibs` 的目录（实际在 out\android_arm64\gradle\examples\AppRTCMobile\symlinked-libs 目录）；
2. 在 `jniLibs` 目录下创建与目标设备CPU架构对应的子目录，例如 `armeabi-v7a`、`arm64-v8a`、`x86`、`x86_64` 等。
3. 将相应 CPU 架构的动态库文件（`.so`文件）放置在相应的子目录中。



#### Invalid transport parameter in ICE URI

在 [apprtc](https://github.com/webrtc/apprtc) *src/app_engine/constants.py* 中，*urls* 是一个 json array

```shell
# ICE_SERVER_OVERRIDE  = [
#   {
#     "urls": [
#       "turn:hostname/IpToTurnServer:19305?transport=udp",
#       "turn:hostname/IpToTurnServer:19305?transport=tcp"
#     ],
#     "username": "TurnServerUsername",
#     "credential": "TurnServerCredentials"
#   },
#   {
#     "urls": [
#       "stun:hostname/IpToStunServer:19302"
#     ]
#   }
# ]
```

但是 android app 将它作为一个字符串处理：

```java
String url = server.getString("urls");
```

将代码更改为：

```Java
 private List<PeerConnection.IceServer> iceServersFromPCConfigJSON(String pcConfig)
      throws JSONException {
    JSONObject json = new JSONObject(pcConfig);
    JSONArray servers = json.getJSONArray("iceServers");
    List<PeerConnection.IceServer> ret = new ArrayList<>();
    for (int i = 0; i < servers.length(); ++i) {
      JSONObject server = servers.getJSONObject(i);
      JSONArray urls = server.getJSONArray("urls");
      String username = server.has("username") ? server.getString("username") : "";
      String credential = server.has("credential") ? server.getString("credential") : "";
      for (int j = 0; j < urls.length(); ++j) {
        String url = urls.getString(j);
        PeerConnection.IceServer turnServer =
                PeerConnection.IceServer.builder(url)
                        .setUsername(username)
                        .setPassword(credential)
                        .createIceServer();
        ret.add(turnServer);
      }
    }
    return ret;
  }
```



## AppRTC Server

采用 docker 部署 AppRTC 服务端，证书使用与 Nginx 一样的证书即可。

```sh
# windows
docker run -e PUBLIC_IP=192.168.5.160 -p 443:443 -p 8089:8089 -p 3478:3478 -p 3478:3478/udp -p 3033:3033 -p 59000-59100:59000-59100/udp -v "$pwd/cert/key.pem:/cert/key.pem" -v "$pwd/cert/cert.pem:/cert/cert.pem" -v "$pwd/logs:/webrtc_avconf" pegome/apprtc

# Linux
docker run -e PUBLIC_IP=apprtc.haoxin.cn -p 443:443 -p 8089:8089 -p 3478:3478 -p 3478:3478/udp -p 3033:3033 -p 59000-59100:59000-59100/udp -v "/root/apprtc/cert/haoxin.cn.key:/cert/key.pem" -v "/root/apprtc/cert/haoxin.cn.pem:/cert/cert.pem" -v "/root/apprtc/logs:/webrtc_avconf" pegome/apprtc
```



参考文章：

- [WebRTC development](https://webrtc.googlesource.com/src/+/main/docs/native-code/development/)
- [mediasoup installation documentation](https://mediasoup.org/documentation/v3/libmediasoupclient/installation/)
- [windows平台下载并编译webrtc代码（代理）2021.8.11](https://blog.csdn.net/gupar/article/details/119642009)
- [webrtc 4577版本vs编译](https://blog.csdn.net/tusong86/article/details/120554374)
- [Checking out and Building Chromium for Windows](https://chromium.googlesource.com/chromium/src/+/master/docs/windows_build_instructions.md)
- [Checking out and building Chromium on Linux](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/linux/build_instructions.md)
- [WebRTC在windows下编译时怎么修改RuntimeLibrary类型](https://blog.csdn.net/haowei0926/article/details/78530560)
- [Linux下编译WebRTC（Linux和Android版本）](https://juejin.cn/post/7040371168897368072)
- [linux下编译 libmediasoupclient, webrtc过程](https://blog.csdn.net/freeman1975/article/details/125251908)
- [ubuntu undefined reference to](https://www.cnblogs.com/chai51/p/16443100.html)
- [在 macOS 12.2.1(Apple M1)/Xcode 13.2.1(MacOSX12.1.sdk) 下编译 libmediasoupclient](https://blog.tubumu.com/2022/03/11/mediasoup-02/)





